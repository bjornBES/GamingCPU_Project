
.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\BIOS.acl
.section TEXT

$BootableDiskNumber = 0x55AA

.SETCPU "BCG16"

.org 0x200
.global _BIOSStart:
    pushr

    sez     SS                                  ; SS = 0
    mov     SP,             @Stack              ; SP = 0x8000

    call    [Initialize]

    call    [FindBootDisk]

    mov     B,              @RAM                ; B = @RAM

    mov     C,              @EndOfBIOS
    mov     D,              @BIOSEnd - @EndOfBIOS

    ; moving the End of the BIOS into RAM
    push    B
    jmp     [MoveToRAM_LOOP]

; this function will use the DL register as the disk index
FindBootDisk:
    push    long @RAM                           ; long uint8_t *data
    push    0x1                                 ; uint8_t sector
    push    0x0                                 ; uint8_t head
    push    word 0x0                            ; uint16_t track
    push    DL                                  ; uint8_t drive
    call    [Read_Sector]

    mov     A,              [RAM + 510]
    cmp     A,              %BootableDiskNumber
    je      [Exit_FindDiskLoop]
    inc     DL
    cmp     DL,             4
    jl      [FindBootDisk]
    mov     AL,             'B'
    push    AL
    jmp     [Error_Invalid_BootDisk]
Exit_FindDiskLoop:
    mov     [DiskNumber],   DL
    retz

.section BSS
DiskNumber:
.resb
ReceivedIRQ:
.resb
Cursorx:
.resw
Cursory:
.resw
EReg:
.resd

.includeil "./BIOS_errors.acl"
.includeil "./IOFunctions.acl"
.includeil "./BIOS_Functions.acl"

EndOfBIOS:
    mov     A,              CR1
    xor     A,              0x01                ; getting out of the BIOS
    mov     CR1,            A

    ; moving the fainal part of the BIOS

    mov     B,              @_BIOSStart         ; B = 0x200
    push    B

    mov     C,              @BIOSEnd
    mov     D,              @End - @BIOSEnd

    push    B
    jmp     [MoveToRAM_LOOP]

; this is at offset 0 when ran
; this code is the code that exites the BIOS
BIOSEnd:

    mov     DL,             [DiskNumber]

    push    long @RAM                           ; long uint8_t *data
    push    0x1                                 ; uint8_t sector
    push    0x0                                 ; uint8_t head
    push    word 0x0                            ; uint16_t track
    push    DL                                  ; uint8_t drive
    call    [Read_Sector]

    popr

    jmp     [$]
End:

.section DATA

.includeil "./BIOS_Interrupt_Pointer.acl"

.section BSS
.org 0x8000
Stack:

.res 0x400

StackEnd:

.section TEXT

.times @MoveToRAM_LOOP - $ .db 0
MoveToRAM_LOOP:
    mov     [B],            byte [C]
    inc     B
    inc     C
    dec     D

    test    D
    jnz     [MoveToRAM_LOOP]

    pop     B
    ; now we are executing the end of the BIOS
    jmp     [B]

.org 0x9000
RAM:

.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\BIOS_errors.acl
Disk_Read_error:
Error_Invalid_BootDisk:
.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\IOFunctions.acl
$variabel_segment = 0x000E

$width = 240
$height = 320

$SRA                = 0x100
$SRB                = 0x101
$MSR                = 0x102

$DRS                = 0x103
$DATA               = 0x104

;
; Arguments:
; uint8_t c         [BP - 6]
; uint8_t color     [BP - 7]
;
; void CharOut(uint8_t c, uint8_t color)
.global CharOut:
    push        BP 
    mov         BP,     SP
    pushr
    push        DS
    push        ES
    mov         HL,     [EReg]
    push        HL

    ; getting arguments
    mov         AL,     [BP - 6]            ; loading the char
    mov         AH,     [BP - 7]            ; loading the color

    ; the some variabels
    mov         C,      [Cursorx]           ; loading cursorx into C
    mov         D,      [Cursory]           ; loading cursory into D

    ; video memory is at 0x0009:8100
    ; writing to VRAM
    mov         ES,     %variabel_segment   
    add         B,      2                   ; now B is 0x3104
    sez         HL

    mov         [EReg], 0x004_0000          ; memory address of VRAM
    add         [EReg], dword C             ; adding the cursorx to the memory address of VRAM

    mov         HL,     dword D             ; Moving D ito HL
    mul         HL,     dword %height       ; getting the X crood using cursory

    add         HL,     [EReg]              ; getting the memory address

    mov byte    [HL],   0x10                ; writing the flags
    mov byte    [HL],   AL                  ; writing the color
    mov byte    [HL],   AH                  ; writing the char data

    pop         HL
    mov         [EReg], [HL]
    pop         ES
    pop         DS
    popr
    pop         BP 
    ret 2

; Arguments:
; long uint8_t* address     [BP - 6] 3 bytes
; uint8_t sector            [BP - 9] 1 byte
; uint8_t Head              [BP - 10] 1 byte
; uint16_t track            [BP - 11] 2 bytes
; uint8_t drive             [BP - 13] 1 byte
;
;
;
; void Read_Sector(uint8_t drive, uint16_t track, uint8_t Head, uint8_t sector, long uint8_t* address)
.global Read_Sector:
    push    BP
    mov     BP,             SP
    pushr

    mov     AL,             [BP - 13]       ; uint8_t head
    push    AL
    mov     A,              [BP - 11]       ; uint16_t Track
    push    A
    mov     AL,             [BP - 10]       ; uint8_t head
    push    AL
    mov     AL,             [BP - 9]        ; uint8_t sector
    push    AL

    call    [Read_Data]

    mov     D,              0x200
    mov     HL,             tbyte [BP - 6]

    ReadDataLoop:
    inb     %DATA,          AL
    mov     [HL],           AL
    inc     HL
    dec     D
    jnz     [ReadDataLoop]

    popr
    pop     BP
    ret     8

.includeil "./Filesystem.acl"

.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\BIOS_Functions.acl

;
; CharInfo* PcharInfo   [BP - 5]
;
; void ACharOut(CharInfo* PcharInfo)
.global ACharOut:
    push        BP 
    mov         BP,     SP
    pushr

    mov         HL,     word [BP - 5]

    mov         A,      word [HL]           ; getting the ascii_char and color_data from the CharInfo

    push        AH                          ; pushing the ascii_char as the first argument
    push        AL                          ; pushing the color_data as the 2nd argument

    call        [CharOut]
    
    popr
    pop         BP 

    ret         CharInfo.sizeof

.struct CharInfo
    ascii_char .resbyte
    color_data .resbyte
.EndStruct

.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\BIOS_Interrupt_Pointer.acl

.section DATA

BIOS_InterruptPointers:

.times (BIOS_IRQ_InterruptPointers - BIOS_InterruptPointers) - 1024 .db 0

; this is for the IRQs Interrupts
BIOS_IRQ_InterruptPointers:
.dd 0                               ; IRQ0: Unused
.dd far @FloppyInterruptHandler     ; IRQ1: FDC interrupt function pointer
.newfile C:\Users\bjorn\Desktop\VideoProjects\GamingCPU_Project\CPU\src\ACL\BIOS\Filesystem.acl
$STR                = 0x100
$MSR                = 0x102

$DRS                = 0x103
$DATA               = 0x104

; 5,25" 512 sector size
$FloppyGPL1         = 0x2A

; 3,5" 512 sector size
$FloppyGPL2         = 0x1B

$SectorSize128      = 0x00
$SectorSize256      = 0x01
$SectorSize512      = 0x02

$Drive1 = 0x00
$Drive2 = 0x01
$Drive3 = 0x02
$Drive4 = 0x03

$CommandRead        = 0x01
$CommandWrite       = 0x02
$CommandRecalibrate = 0x03

.global Initialize:
    push    BP
    mov     BP,             SP
    pushr

    popr
    ret     0

; Arguments:
; uint8_t head              [BP - 6]
; uint16_t track            [BP - 7]
; uint8_t sector            [BP - 9]
; uint8_t data_length       [BP - 10]
; uint8_t drive             [BP - 11]
;
; Read data from a specified sector of a floppy disk
;
; void Read_Data(uint8_t drive, uint8_t data_length, uint8_t head, uint16_t cylinder, uint8_t sector);

Read_Data:
    push    BP
    mov     BP,             SP
    pushr

    mov     AL,             %CommandRead        ; command code for Read data
    outb    %DATA,          AL                  ; write the command to the FDC command register

    mov     AL,             [BP - 11]           ; drive number
    and     AL,             0x03                ; masking the 0b0000_0011

    rol     AL,             6                   ; rolling AL 6 times 0b1100_0000
    mov     BL,             [BP - 6]            ; getting the Head
    or      AL,             BL                  ; now it's 0bDD00_HHHH
    outb    %DATA,          AL
        
    mov     A,              [BP - 7]            ; track number
    outb    %DATA,          A

    mov     AL,             [BP - 9]            ; Sector
    outb    %DATA,          AL

    WaitForData:
    inb     %MSR,           AL
    and     AL,             0x80
    jz      [WaitForData]

    popr
    pop     BP
    ret     5

; Arguments:
; long uint8_t *data        [BP - 6]
; uint8_t data_length       [BP - 9]
; uint8_t sector            [BP - 10]
; uint8_t head              [BP - 11]
; uint16_t track            [BP - 12]
; uint8_t drive             [BP - 14]
;
; Write data to a specified sector of a floppy disk
;
; void Write_Data(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t data_length, const uint8_t *data);

.global Write_Data:

; Read the identification field of a sector
; Arguments:
; long uint8_t *id_field:
; uint8_t sector:
; uint8_t head:
; uint16_t cylinder:
; uint8_t drive:
; void Read_ID(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t *id_field);

; Write deleted data to a specified sector
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - const uint8_t *data: Pointer to buffer with data to write (INPUT)
; void Write_Deleted_Data(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, const uint8_t *data);

; Read deleted data from a specified sector
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - uint8_t *buffer: Pointer to buffer where read data will be stored (OUTPUT)
; void Read_Deleted_Data(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t *buffer);

; Arguments:
; uint16_t track            [BP - 6]
; uint8_t drive             [BP - 8]
;
; Move the read/write head to a specific track
;
; void Seek(uint8_t drive, uint16_t track);
.global Seek:

; Arguments:
; uint8_t Drive             [BP - 6]
; uint8_t Head              [BP - 7]
;
; Recalibrate the drive (move the head to track 0)
;
; void Recalibrate(uint8_t drive, uint8_t head);
.global Recalibrate:
    push    BP
    mov     BP,             SP
    pushr

    mov     AL,             %CommandRecalibrate ; command code for Read data
    outb    %DATA,          AL                  ; write the command to the FDC command register

    mov     AL,             [BP - 6]            ; drive number
    and     AL,             0x03                ; masking the 0b0000_0011

    rol     AL,             6                   ; rolling AL 6 times 0b1100_0000
    mov     BL,             [BP - 7]            ; getting the Head
    or      AL,             BL                  ; now it's 0bDD00_HHHH
    outb    %DATA,          AL

wait_irq:
    mov     AL,             [ReceivedIRQ]
    jz      [wait_irq]

    mov     [ReceivedIRQ],  0    

    popr
    pop     BP
    ret     1

; Sense the interrupt status
; Arguments:
;   - uint8_t *status: Pointer to buffer where interrupt status will be stored (OUTPUT)
; void Sense_Interrupt_Status(uint8_t *status);

; Format a specified track
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t track: Track number to format
; void Format_Track(uint8_t drive, uint16_t track);

; Sense the status of a specified drive
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint8_t *status: Pointer to buffer where drive status will be stored (OUTPUT)
; void Sense_Drive_Status(uint8_t drive, uint8_t *status);

; Specify various operational parameters
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t parameters: Configuration parameters (e.g., data rate, step rate)
; void Specify(uint8_t drive, uint16_t parameters);

; Read an entire track of data
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t track: Track number to read
;   - uint8_t *buffer: Pointer to buffer where read data will be stored (OUTPUT)
; void Read_Track(uint8_t drive, uint16_t track, uint8_t *buffer);

; Read the version number of the controller
; Arguments:
;   - uint8_t *version: Pointer to buffer where version number will be stored (OUTPUT)
; void Read_Version(uint8_t *version);

; Dump the contents of the controller's internal registers
; Arguments:
;   - uint8_t *registers: Pointer to buffer where register contents will be dumped (OUTPUT)
; void Dump_Registers(uint8_t *registers);

; Scan data for equality with a specific value
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - uint8_t value: Value to compare with (INPUT)
;   - uint8_t *result: Pointer to buffer where result will be stored (OUTPUT)
; void Scan_Equal(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t value, uint8_t *result);

; Configure the drive for perpendicular recording
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint8_t mode: Mode to set (e.g., 0 for normal, 1 for perpendicular)
; void Perpendicular_Mode(uint8_t drive, uint8_t mode);

; Configure various operational parameters
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t config: Configuration settings (INPUT)
; void Configure(uint8_t drive, uint16_t config);

; Lock or unlock the controller’s configuration
; Arguments:
;   - uint8_t lock: 1 to lock, 0 to unlock
; void Lock(uint8_t lock);

; Verify the data on a specified sector
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - uint8_t *status: Pointer to buffer where verify status will be stored (OUTPUT)
; void Verify(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t *status);

; Scan data to check if it is less than or equal to a specific value
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - uint8_t value: Value to compare with (INPUT)
;   - uint8_t *result: Pointer to buffer where result will be stored (OUTPUT)
; void Scan_Low_Or_Equal(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t value, uint8_t *result);

; Scan data to check if it is greater than or equal to a specific value
; Arguments:
;   - uint8_t drive: Drive number (0-3)
;   - uint16_t cylinder: Cylinder (track) number
;   - uint8_t head: Head number (0 or 1)
;   - uint8_t sector: Sector number (1-18)
;   - uint8_t value: Value to compare with (INPUT)
;   - uint8_t *result: Pointer to buffer where result will be stored (OUTPUT)
; void Scan_High_Or_Equal(uint8_t drive, uint16_t cylinder, uint8_t head, uint8_t sector, uint8_t value, uint8_t *result);

.global FloppyInterruptHandler:
    mov     [ReceivedIRQ],  1

    rti